// This Jenkinsfile replaces Jenkinsfile, Jenkinsfile-backend, Jenkinsfile-frontend, and Jenkinsfile-main

def microservices = [
    'api-gateway',
    'account-management',
    'transaction-service',
    'loan-management',
    'savings-goals',
    'risk-assessment',
    'compliance',
    'notification-service',
    'reporting'
]

def frontendService = 'web-frontend'

pipeline {
    agent any

    tools {
        // Assuming tools are configured globally in Jenkins
        maven 'M3' 
        jdk 'JDK 17'
        nodejs 'Node 18'
    }

    environment {
        // Credentials should be managed in Jenkins UI and referenced here
        DOCKER_REGISTRY = credentials('docker-registry-url')
        DOCKER_CREDENTIALS = credentials('docker-credentials')
        SONARQUBE_TOKEN = credentials('sonarqube-token')
        SONARQUBE_URL = credentials('sonarqube-url')
        KUBE_CONFIG = credentials('kubernetes-config')
        // Use a consistent image repository name
        IMAGE_REPO = "finovabackend" 
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Build & Test') {
            parallel {
                stage('Backend Build & Test') {
                    steps {
                        dir('backend') {
                            sh 'mvn clean package -DskipTests'
                            sh 'mvn test'
                        }
                    }
                    post {
                        always {
                            junit 'backend/**/target/surefire-reports/*.xml'
                        }
                    }
                }

                stage('Frontend Build & Test') {
                    steps {
                        dir(frontendService) {
                            sh 'npm ci'
                            sh 'npm run lint'
                            sh 'npm test -- --coverage'
                            sh 'npm run build'
                        }
                    }
                    post {
                        always {
                            // Assuming publishHTML is available via a plugin
                            script {
                                try {
                                    publishHTML(target: [
                                        allowMissing: false,
                                        alwaysLinkToLastBuild: true,
                                        keepAll: true,
                                        reportDir: "${frontendService}/coverage",
                                        reportFiles: 'index.html',
                                        reportName: 'Frontend Test Coverage'
                                    ])
                                } catch (e) {
                                    echo "Warning: publishHTML failed. Is the plugin installed? Error: ${e}"
                                }
                            }
                        }
                    }
                }
            }
        }
        
        stage('Code Quality (SonarQube)') {
            steps {
                dir('backend') {
                    withSonarQubeEnv('SonarQube') {
                        sh 'mvn sonar:sonar -Dsonar.projectKey=finovabank-backend -Dsonar.host.url=${SONARQUBE_URL} -Dsonar.login=${SONARQUBE_TOKEN}'
                    }
                }
            }
        }

        stage('Docker Build & Push') {
            steps {
                script {
                    // Login to Docker registry
                    withCredentials([usernamePassword(credentialsId: env.DOCKER_CREDENTIALS, passwordVariable: 'DOCKER_PASSWORD', usernameVariable: 'DOCKER_USERNAME')]) {
                        sh "echo \$DOCKER_PASSWORD | docker login ${env.DOCKER_REGISTRY} -u \$DOCKER_USERNAME --password-stdin"
                    }

                    // Build and push backend microservices
                    microservices.each { service ->
                        dir("backend/${service}") {
                            def imageTag = "${env.DOCKER_REGISTRY}/${env.IMAGE_REPO}/${service}:${env.BUILD_NUMBER}"
                            sh "docker build -t ${imageTag} ."
                            sh "docker push ${imageTag}"
                            
                            if (env.BRANCH_NAME == 'main') {
                                sh "docker tag ${imageTag} ${env.DOCKER_REGISTRY}/${env.IMAGE_REPO}/${service}:latest"
                                sh "docker push ${env.DOCKER_REGISTRY}/${env.IMAGE_REPO}/${service}:latest"
                            }
                        }
                    }
                    
                    // Build and push frontend
                    dir(frontendService) {
                        def imageTag = "${env.DOCKER_REGISTRY}/${env.IMAGE_REPO}/${frontendService}:${env.BUILD_NUMBER}"
                        sh "docker build -t ${imageTag} ."
                        sh "docker push ${imageTag}"
                        
                        if (env.BRANCH_NAME == 'main') {
                            sh "docker tag ${imageTag} ${env.DOCKER_REGISTRY}/${env.IMAGE_REPO}/${frontendService}:latest"
                            sh "docker push ${env.DOCKER_REGISTRY}/${env.IMAGE_REPO}/${frontendService}:latest"
                        }
                    }
                }
            }
        }

        stage('Deploy to Kubernetes') {
            when {
                branch 'main'
            }
            steps {
                script {
                    // Configure kubectl
                    sh 'mkdir -p ~/.kube'
                    sh 'echo "${KUBE_CONFIG}" > ~/.kube/config'
                    
                    // Use the refactored Helm chart for deployment
                    sh 'helm upgrade --install finovabank ./kubernetes --wait'
                    
                    // Verification
                    sh 'kubectl get deployments -n default'
                    sh 'kubectl get services -n default'
                }
            }
        }
        
        stage('Integration & Smoke Tests') {
            when {
                branch 'main'
            }
            steps {
                echo "Running integration and smoke tests against deployed services"
                // Placeholder for actual test commands
                sh 'echo "Integration and smoke tests would run here"'
            }
        }
    }

    post {
        always {
            cleanWs()
        }
        success {
            echo 'FinovaBank CI/CD pipeline completed successfully!'
        }
        failure {
            echo 'FinovaBank CI/CD pipeline failed!'
        }
    }
}

